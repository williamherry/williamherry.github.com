<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: docker | William's Blog with Octopress]]></title>
  <link href="http://williamherry.com/blog/categories/docker/atom.xml" rel="self"/>
  <link href="http://williamherry.com/"/>
  <updated>2015-07-21T08:25:35+08:00</updated>
  <id>http://williamherry.com/</id>
  <author>
    <name><![CDATA[William Herry]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[使用Docker搭建一个Rails开发环境]]></title>
    <link href="http://williamherry.com/blog/2015/01/22/build-rails-dev-env-using-docker/"/>
    <updated>2015-01-22T14:56:00+08:00</updated>
    <id>http://williamherry.com/blog/2015/01/22/build-rails-dev-env-using-docker</id>
    <content type="html"><![CDATA[<p>如果使用的fig的话那就太简单了,照着fig官方文档分分钟就可以搞定,但是它的方法存在一个问题,他是直接用的ruby,postgres,redis的image,整个加起来就上G了,国内的这破网速,虽然只需下载一次就好了,并且国内也有镜像加速的服务如daocloud,但实际使用发现任然无法接受.所以我的方法是使用一个基本的ubuntu镜像,其他镜像在此基础上构建而成</p>

<p>首先是多官方的ubuntu镜像做稍微修改,这个修改就是把源换成网易的,然后制作成一个镜像,其他的镜像都一次为基础</p>

<p>想看一下相关的文件:</p>

<p>```</p>

<h1>tree .</h1>

<p>├── Dockerfile
├── docker
│   ├── gemrc
│   ├── postgres
│   │   ├── Dockerfile
│   │   ├── pg_hba.conf
│   │   ├── postgresql.conf
│   │   └── run
│   └── redis
│       ├── Dockerfile
│       └── redis.conf
└── fig.yml
```</p>

<p>我们使用fig来编排,所以fig.yml就是主要的入口了,内容如下:</p>

<p>```
db:
  build: ./docker/postgres
redis:
  build: ./docker/redis
web:
  build: .
  command: bundle exec rails s -b 0.0.0.0 -p 3000
  volumes:</p>

<pre><code>- .:/myapp
</code></pre>

<p>  ports:</p>

<pre><code>- "3000:3000"
</code></pre>

<p>  links:</p>

<pre><code>- db
- redis
</code></pre>

<p>```</p>

<p>这里有三个部分,前面两个都是知道从什么地方找Dockerfile来build镜像(fig官方的例子这里是用的image: postgres)</p>

<p>第三个就是实际跑rails的image了,它指定了一个image启动后运行的命令(其他两个镜像也有启动后要执行的命令,是在Dockerfile里指定),然后有一个volumes把代码目录镜像到images是,这样修改了代码不用做操作就可以看到效果</p>

<p>ports指令把image里的端口映射到宿主机上,宿主机并不一定就是我们的开发机,像Mac使用boot2docker安装的docker,那么开发机就是运行docker的虚拟机了,可以用boot2docker ip得到ip地址,等之后配置完成了就可以用这个地址加3000端口查看网页了</p>

<p>最后的links会在web的image执行的时候(就是container)在其的/etc/hosts里加一条到其他container地址的对应,要知道每个container运行IP都是不一样的,这样就可以在web去连db和redis了,相应的database.yml里把host写成db就可以了</p>

<p>我们一个一个来看他们是怎么build的</p>

<p>```</p>

<h1>cat docker/postgres/Dockerfile</h1>

<p>FROM williamherry/ubuntu
MAINTAINER William Herry <a href="&#109;&#97;&#105;&#x6c;&#116;&#x6f;&#58;&#87;&#105;&#108;&#108;&#x69;&#x61;&#109;&#72;&#101;&#x72;&#x72;&#x79;&#67;&#104;&#x69;&#110;&#x61;&#x40;&#x47;&#109;&#x61;&#105;&#108;&#x2e;&#99;&#x6f;&#x6d;">&#87;&#x69;&#108;&#108;&#105;&#x61;&#109;&#72;&#101;&#114;&#x72;&#121;&#67;&#104;&#105;&#x6e;&#97;&#64;&#71;&#109;&#97;&#x69;&#x6c;&#46;&#x63;&#111;&#109;</a>
ENV DOCKERFILE_VERSION 0.0.1.1</p>

<p>RUN locale-gen en_US.UTF-8
RUN update-locale LANG=en_US.UTF-8</p>

<p>RUN apt-get -qqy update &amp;&amp; DEBIAN_FRONTEND=noninteractive apt-get install -qqy postgresql-9.3 postgresql-contrib-9.3 postgresql-9.3-postgis-2.1 libpq-dev sudo</p>

<h1>/etc/ssl/private can&rsquo;t be accessed from within container for some reason</h1>

<h1>(@andrewgodwin says it&rsquo;s something AUFS related)</h1>

<p>RUN mkdir /etc/ssl/private-copy; mv /etc/ssl/private/* /etc/ssl/private-copy/; rm -r /etc/ssl/private; mv /etc/ssl/private-copy /etc/ssl/private; chmod -R 0700 /etc/ssl/private; chown -R postgres /etc/ssl/private</p>

<p>ADD postgresql.conf /etc/postgresql/9.3/main/postgresql.conf
ADD pg_hba.conf /etc/postgresql/9.3/main/pg_hba.conf
RUN chown postgres:postgres /etc/postgresql/9.3/main/*.conf</p>

<p>ADD main /var/lib/postgresql/9.3/main
RUN chown -R postgres:postgres /var/lib/postgresql/9.3/main</p>

<p>ADD run /usr/local/bin/run
RUN chmod +x /usr/local/bin/run</p>

<p>EXPOSE 5432
CMD [&ldquo;/usr/local/bin/run&rdquo;]
```</p>

<p>这个是直接抄的<a href="https://github.com/orchardup/docker-postgresql,">https://github.com/orchardup/docker-postgresql,</a> 刚发现他github项目主页就是这个已经是Deprecated,请使用官方镜像</p>

<p>简单说就是安装postgresql,把配置文件改改,让访问权限宽松一点,在启动起来</p>

<p><code>
ADD main /var/lib/postgresql/9.3/main
RUN chown -R postgres:postgres /var/lib/postgresql/9.3/main
</code></p>

<p>上面这两行是我添加的,实现把一些初始数据导入,把postgresql数据目录的文件整个放在<code>docker/postgres/main</code>下面build镜像,就可以一启动就有seed数据了</p>

<p>下面看看redis的Dockerfile</p>

<p>```</p>

<h1>cat docker/redis/Dockerfile</h1>

<p>FROM williamherry/ubuntu
MAINTAINER William Herry <a href="&#109;&#97;&#x69;&#x6c;&#116;&#x6f;&#58;&#x57;&#x69;&#x6c;&#x6c;&#x69;&#x61;&#x6d;&#72;&#101;&#114;&#x72;&#121;&#x43;&#x68;&#105;&#110;&#97;&#64;&#x47;&#x6d;&#97;&#105;&#x6c;&#x2e;&#99;&#111;&#109;">&#87;&#105;&#x6c;&#108;&#x69;&#97;&#x6d;&#x48;&#101;&#114;&#114;&#121;&#67;&#104;&#x69;&#110;&#97;&#x40;&#x47;&#109;&#x61;&#x69;&#x6c;&#46;&#99;&#111;&#109;</a>
ENV DOCKERFILE_VERSION 0.0.1</p>

<p>RUN apt-get update -qqy &amp;&amp; apt-get install -qqy redis-server</p>

<p>ADD redis.conf /etc/redis/redis.conf
CMD [&ldquo;redis-server&rdquo;, &ldquo;/etc/redis/redis.conf&rdquo;]</p>

<p>EXPOSE 6379
```</p>

<p>这个就更简单了,安装,加个配置文件,启动</p>

<p>配置文件主要修改了两个地方:</p>

<p><code>
daemonize no
bind 0.0.0.0
</code></p>

<p>似乎docker在后台运行是不行的</p>

<p>最后我们看看web的Dockerfile</p>

<p>```</p>

<h1>cat Dockerfile</h1>

<p>FROM williamherry/ubuntu
MAINTAINER William Herry <a href="&#x6d;&#97;&#105;&#x6c;&#116;&#111;&#x3a;&#87;&#105;&#x6c;&#x6c;&#x69;&#x61;&#109;&#x48;&#101;&#114;&#114;&#x79;&#x43;&#104;&#105;&#110;&#97;&#x40;&#x47;&#x6d;&#97;&#x69;&#x6c;&#46;&#99;&#111;&#109;">&#87;&#105;&#108;&#x6c;&#x69;&#97;&#109;&#72;&#x65;&#114;&#114;&#x79;&#67;&#x68;&#x69;&#x6e;&#97;&#x40;&#71;&#109;&#x61;&#x69;&#x6c;&#46;&#x63;&#x6f;&#109;</a>
ENV DOCKERFILE_VERSION 0.0.1</p>

<p>ENV RUBY_MAJOR 2.1
ENV RUBY_VERSION 2.1.5
ENV RUBY_SRC_DIR /usr/src/ruby</p>

<h1>Essentials</h1>

<p>RUN apt-get update -qqy \
  &amp;&amp; apt-get install -qqy \</p>

<pre><code>autoconf \
build-essential \
curl \
git \
imagemagick \
libbz2-dev \
libcurl4-openssl-dev \
libevent-dev \
libffi-dev \
libglib2.0-dev \
libjpeg-dev \
libmagickcore-dev \
libmagickwand-dev \
libmysqlclient-dev \
libncurses-dev \
libpq-dev \
libreadline-dev \
libsqlite3-dev \
libssl-dev \
libxml2-dev \
libxslt-dev \
libyaml-dev \
procps \
zlib1g-dev \
</code></pre>

<p>  &amp;&amp; rm -rf /var/lib/apt/lists/*</p>

<p>RUN apt-get update -qqy \
  &amp;&amp; apt-get install -qqy locales \
  &amp;&amp; rm -rf /var/lib/apt/lists/* \
  &amp;&amp; localedef -i en_US -c -f UTF-8 -A /usr/share/locale/locale.alias en_US.UTF-8
ENV LANG en_US.utf8</p>

<h1>Ruby specifics</h1>

<p>RUN apt-get update -qqy \
  &amp;&amp; apt-get install -qqy \</p>

<pre><code>bison \
ruby \
</code></pre>

<p>  &amp;&amp; rm -rf /var/lib/apt/lists/* \
  &amp;&amp; mkdir -p $RUBY_SRC_DIR \
  &amp;&amp; curl -s -SL &ldquo;<a href="http://ruby.taobao.org/mirrors/ruby/2.1/ruby-$RUBY_VERSION.tar.bz2">http://ruby.taobao.org/mirrors/ruby/2.1/ruby-$RUBY_VERSION.tar.bz2</a>&rdquo; \</p>

<pre><code>| tar -xjC $RUBY_SRC_DIR --strip-components=1
</code></pre>

<p>WORKDIR $RUBY_SRC_DIR</p>

<p>RUN autoconf \
  &amp;&amp; ./configure \</p>

<pre><code>--disable-install-doc \
</code></pre>

<p>  &amp;&amp; make -j"$(nproc)&ldquo; \
  &amp;&amp; apt-get purge -qqy &mdash;auto-remove bison ruby \
  &amp;&amp; make install \
  &amp;&amp; rm -r /usr/src/ruby</p>

<p>RUN mkdir /myapp
WORKDIR /myapp
ADD . /myapp
ADD config/database.yml.fig /myapp/config/database.yml
ADD config/secrets.yml.fig /myapp/config/secrets.yml
ADD docker/gemrc /root/.gemrc
RUN gem install bundler
RUN bundle install
```</p>

<p>前面那部分是网上找的安装ruby的配制方法,你可能不能理解为什么要自己安装ruby,你可以直接用官方ruby镜像,只要把FROM后面改成ruby就可以了,就是比较大而已,我发现下载安装好ruby的镜像还没从ubuntu镜像安装来的快</p>

<p>设置好之后就可以用下面的命令启动开发环境了(如果有数据放docker/postgres/main下,fig up就够了)</p>

<p><code>
fig up -d db
fig run web rake db:setup
fig up
</code></p>

<p>从mkdir开始才是正在起作用的,太简单就不用说了,这里的.gemrc里知道了taobao的源,这样安装bundler就会快一点</p>

<p>最后说说踩过的一个坑,你可能注意到了每一个Dockerfile前面都有<code>ENV DOCKERFILE_VERSION 0.0.1</code>这一行,刚开始是<code>ENV VERSION 0.0.1</code>,这样会有一个问题,就是在执行migration的时候干脆不跑了,花了我一天的时间debug,最后发现他会把这个变量传进去,<code>rake db:migrate</code>就相当于<code>rake db:migrate VERSION=0.0.1</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[理解Docker镜像的存储原理]]></title>
    <link href="http://williamherry.com/blog/2015/01/14/how-docker-image-works-with-aufs/"/>
    <updated>2015-01-14T15:09:00+08:00</updated>
    <id>http://williamherry.com/blog/2015/01/14/how-docker-image-works-with-aufs</id>
    <content type="html"><![CDATA[<p>一开始接触Docker就对他镜像的存储原理很感兴趣,有一个问题一直不明白,Commit一个镜像的时候到底把什么存下来了,只知道他是使用分层的AUFS,具体不是特别很清楚,直到看了这篇关于<a href="http://www.thegeekstuff.com/2013/05/linux-aufs/">Linux AuFS的文章</a>,才有一个自己的认识,对不对还不知道</p>

<p>如果你用过Photoshop,那么用类比的方法就很好理解了,PS里作图一般都是一层一层的,上层如果没有内容就会透过去显示下层的内容,如果有旧覆盖下层内容.假设从下到上有ABC三层,A层上有一个红点,B层上靠右的地方有一个绿点(没有和A层上的重叠),如果只有这两层,那我们看到的就是一个红点加几个绿点,现在在上面有加一层C,他上面有一个蓝点和A层上红点的位置重叠,那么他就会覆盖A层的红点,最后我们看到的就是一个蓝点一个绿点</p>

<p>类比到文件也是这样,假设一个目录<code>/XXX</code>由自底向上的ABC三层组成,他们每一层都有一个和他们名字对应的文件(A=>A.txt, ..),同时他们都有一个叫<code>common.txt</code>文件,里面的内容分别是A,B,C,那么最终的结果是<code>/XXX</code>目录共有4个文件,<code>A.txt</code>, <code>B.txt</code>, <code>C.txt</code>和<code>common.txt</code>,而<code>common.txt</code>里的内容是C(最上层覆盖下层的)</p>

<p>我们可以用一个例子看看:</p>

<p>首先创建三个目录:</p>

<p><code>
mkdir -p /tmp/aufs/root
mkdir -p /tmp/aufs/layer1
mkdir -p /tmp/aufs/layer2
</code></p>

<p>创建相应的文件</p>

<p>```
echo &lsquo;root&rsquo; > /tmp/aufs/root/root.txt
echo &lsquo;layer1&rsquo; > /tmp/aufs/layer1/layer1.txt
echo &lsquo;layer2&rsquo; > /tmp/aufs/layer2/layer2.txt</p>

<p>echo &lsquo;root&rsquo; > /tmp/aufs/root/common.txt
echo &lsquo;layer1&rsquo; > /tmp/aufs/root/common.txt
echo &lsquo;layer2&rsquo; > /tmp/aufs/root/common.txt
```</p>

<p>然后我们把他们按顺序Mount起来</p>

<p><code>
mount -t aufs -o br=/tmp/aufs/layer2:/tmp/aufs/layer1:/tmp/aufs/root none /tmp/aufs/root
</code></p>

<p>br后面的参数顺序是越后面越底层</p>

<p>现在<code>/tmp/aufs/root/</code>下应该有4个文件,<code>root.txt</code>, <code>layer1.txt</code>, <code>layer2.txt</code>和<code>common.txt</code>,并且<code>common.txt</code>里面的内容应该是<code>layer2</code>.同时由于现在layer2是最上层,那么<code>/tmp/aufs/root</code>里面做修改会反映到<code>/tmp/aufs/layer2</code>,在<code>/tmp/aufs/root</code>里创建文件,<code>/tmp/aufs/layer2</code>里也会出现</p>

<p>再回到前面的问题,Commit的时候到底保存的是什么呢,假设我们要基于前面的三层做修改在提交,只要再在上面加一层layer3,然后对<code>/tmp/aufs/root</code>做修改</p>

<p><code>
mkdir -p /tmp/aufs/layer3
umount /tmp/aufs/root
mount -t aufs -o br=/tmp/aufs/layer3:/tmp/aufs/layer2:/tmp/aufs/layer1:/tmp/aufs/root none /tmp/aufs/root
</code></p>

<p>Note: 没有找到可以一层一层加的方法,只能先umount在按顺序mount</p>

<p>然后再<code>/tmp/aufs/root</code>下做修改</p>

<p><code>
echo 'layer3' &gt; /tmp/aufs/root/layer3.txt
echo 'layer3' &gt; /tmp/aufs/root/common.txt
</code></p>

<p>这时候看<code>/tmp/aufs/layer3</code>目录,应该看到会有这两个文件,我们就可以把这个目录打个包实现Commit的目的</p>

<p>把这样的每一层保存下来,并想办法记录他们之间的关系(某一层的上层和下层是谁),差不多就可以实现Docker的镜像存储了,不过不一定对,具体怎么做得看了代码才知道</p>
]]></content>
  </entry>
  
</feed>
